<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D City Emulator</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: Arial, sans-serif;
    }

    #container {
      width: 100%;
      height: 100%;
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
    }

    #stats-display {
      margin-top: 10px;
    }

    button {
      margin-top: 5px;
      padding: 5px 10px;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <div id="ui">
    <button id="toggleDayNight">Toggle Day/Night</button>
    <button id="generateCity">Generate New City</button>
    <div id="stats-display">
      Time: <span id="timeOfDay">Day</span><br>
      Population: <span id="population">0</span>
    </div>
  </div>

  <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/",
                "pedestrian_functions": "./pedestrian_functions.js"
            }
        }
    </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import Stats from 'three/addons/libs/stats.module.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'; // Import GLTFLoader
    import { OBJExporter } from 'three/addons/exporters/OBJExporter.js'; // Import OBJExporter
    import { createPedestrians, updatePedestrians } from 'pedestrian_functions'; // Import pedestrian functions

    // --- Core Variables ---
    let scene, camera, renderer, controls, stats;
    let ambientLight, directionalLight, hemisphereLight;
    let clock = new THREE.Clock();
    let isDay = true;
    let timeOfDay = 0.5; // 0 = midnight, 0.5 = noon, 1 = midnight
    const cycleSpeed = 0.02; // Speed of day/night cycle

    // --- City Elements ---
    let groundPlane;
    // let buildingInstances; // Replaced by buildingMeshes object
    // let windowGlowInstances; // Removed for now
    let buildingMeshes = {}; // Object to hold InstancedMesh per material type
    let streetLights = [];
    let vehicles = [];
    let pedestrians = []; // Array to hold pedestrian data
    let sidewalkInstances = null; // InstancedMesh for sidewalks
    const citySize = 1300; // Size of the ground plane
    const roadWidth = 20;
    const buildingPlotSize = 50;
    const pavementWidth = 5;
    const gridSize = Math.floor(citySize / (buildingPlotSize + pavementWidth * 2));
    let cityGrid = []; // 2D array to store plot types (building, road, park)

    // --- Simulation Parameters ---
    let population = 0;

    // --- Preloaded Models ---
    let carModel = null;
    let truckModel = null;
    // Remove pedestrian model variables
    // Remove FBXLoader instance
    const loader = new GLTFLoader(); // Use original name 'loader'

    // --- Model Loading and Initialization ---
    function loadModelsAndInit() {
      let modelsLoaded = 0;
      const totalModels = 2; // Back to Car, Truck only

      const checkAllModelsLoaded = () => {
        modelsLoaded++;
        if (modelsLoaded === totalModels) {
          console.log("All models loaded, initializing scene...");
          init(); // Call init only after all models are loaded
        }
      };

      // Load Car Model
      loader.load( // Use original loader variable
        'models/car.glb',
        (gltf) => {
          carModel = gltf.scene;
          // Calculate and log size
          const box = new THREE.Box3().setFromObject(carModel);
          const size = box.getSize(new THREE.Vector3());
          console.log('Car Model Loaded. Size:', size.x.toFixed(2), 'x', size.y.toFixed(2), 'x', size.z.toFixed(2));
          // Set shadow properties on the original loaded model
          carModel.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true; // Also receive shadows
            }
          });
          checkAllModelsLoaded();
        },
        undefined, // Progress callback (optional)
        (error) => {
          console.error('Error loading car model:', error);
          checkAllModelsLoaded(); // Still proceed even if one fails? Or handle differently?
        }
      );

      // Load Truck Model
      loader.load( // Use original loader variable
        'models/truck.glb',
        (gltf) => {
          truckModel = gltf.scene;
          // Calculate and log size
          const box = new THREE.Box3().setFromObject(truckModel);
          const size = box.getSize(new THREE.Vector3());
          console.log('Truck Model Loaded. Size:', size.x.toFixed(2), 'x', size.y.toFixed(2), 'x', size.z.toFixed(2));
          // Set shadow properties on the original loaded model
          truckModel.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true; // Also receive shadows
            }
          });
          checkAllModelsLoaded();
        },
        undefined, // Progress callback (optional)
        (error) => {
          console.error('Error loading truck model:', error);
          checkAllModelsLoaded(); // Still proceed
        }
      );
      // Removed FBX Loader section
    }


    // --- Initialization ---
    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb); // Start with sky blue

      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
      camera.position.set(150, 200, 250);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('container').appendChild(renderer.domElement);

      // Lighting
      ambientLight = new THREE.AmbientLight(0xffffff, 0.3); // Soft white light
      scene.add(ambientLight);

      directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Sun light
      directionalLight.position.set(150, 300, 200);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 50;
      directionalLight.shadow.camera.far = 1000;
      directionalLight.shadow.camera.left = -citySize / 1.5;
      directionalLight.shadow.camera.right = citySize / 1.5;
      directionalLight.shadow.camera.top = citySize / 1.5;
      directionalLight.shadow.camera.bottom = -citySize / 1.5;
      scene.add(directionalLight);
      scene.add(directionalLight.target); // Target for the light

      hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x080820, 0.1); // Sky color, ground color, intensity
      scene.add(hemisphereLight);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 50;
      controls.maxDistance = 1500;
      controls.maxPolarAngle = Math.PI / 2.1; // Prevent looking straight down or below ground

      // Stats (Performance Monitor)
      stats = new Stats();
      document.body.appendChild(stats.dom);

      // Ground Plane
      createGround();

      // Generate City Layout
      generateCityLayout(); // Includes createBuildings, createInfrastructure

      // Create Traffic
      createTraffic(); // Call the traffic creation function



      // Create Pedestrians
      createPedestrians(THREE, scene, pedestrians, cityGrid, gridSize, buildingPlotSize, pavementWidth); // Call the imported pedestrian creation function

      // Event Listeners
      document.getElementById('generateCity').addEventListener('click', regenerateCity);

      // Start Animation Loop
      animate();
    }

    // --- Ground Plane ---
    function createGround() {
      // Create material first, texture will be assigned later
      const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x404040 }); // Default color
      const groundGeometry = new THREE.PlaneGeometry(citySize, citySize);
      groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
      groundPlane.rotation.x = -Math.PI / 2;
      groundPlane.receiveShadow = true;
      scene.add(groundPlane);
    }

    // Texture creation moved to generateCityLayout, but function definition remains
    function createGroundTexture() {
      const canvas = document.createElement('canvas');
      const texSize = 1024; // Increased texture size for better detail
      canvas.width = texSize;
      canvas.height = texSize;
      const context = canvas.getContext('2d');

      // Recalculate texture dimensions based on direct scaling from world size
      const scaleFactor = texSize / citySize; // Pixels per world unit
      const plotStepTex = (buildingPlotSize + pavementWidth * 2) * scaleFactor; // Size of a grid cell in pixels
      const buildingPlotTex = buildingPlotSize * scaleFactor; // Size of building/park base in pixels
      const pavementTex = pavementWidth * scaleFactor; // Width of pavement strip in pixels
      // Ensure plotStepTex is consistent with texSize/gridSize (should be close due to float precision)
      // console.log("Calculated plotStepTex:", plotStepTex, "vs texSize/gridSize:", texSize / gridSize);

      // Base road color
      context.fillStyle = '#404040'; // Dark grey for roads
      context.fillRect(0, 0, texSize, texSize);

      // Draw grid cells
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const cellX = i * plotStepTex;
          const cellY = j * plotStepTex; // Canvas Y corresponds to world Z

          if (cityGrid[i][j].type === 'building' || cityGrid[i][j].type === 'park') {
            // Draw pavement around building/park plot
            context.fillStyle = '#a0a0a0'; // Light grey pavement
            context.fillRect(cellX, cellY, plotStepTex, plotStepTex);

            // Draw building/park base area (slightly darker)
            const baseColor = cityGrid[i][j].type === 'park' ? '#557755' : '#606060'; // Greenish for park, grey for building
            context.fillStyle = baseColor;
            context.fillRect(cellX + pavementTex, cellY + pavementTex, buildingPlotTex, buildingPlotTex);

          } else {
            // Road plot - already filled with base road color
            // Optional: Add road markings (e.g., center line)
            context.strokeStyle = '#c0c0c0'; // White-ish lines
            context.lineWidth = Math.max(1, pavementTex / 10); // Thin lines
            context.setLineDash([pavementTex / 2, pavementTex / 2]); // Dashed lines

            // Simple center lines (only if adjacent cells are also roads)
            let isRoadRight = (i < gridSize - 1) && cityGrid[i + 1][j].type === 'road';
            let isRoadDown = (j < gridSize - 1) && cityGrid[i][j + 1].type === 'road';

            if (isRoadRight) {
              context.beginPath();
              context.moveTo(cellX + plotStepTex / 2, cellY + plotStepTex / 2);
              context.lineTo(cellX + plotStepTex, cellY + plotStepTex / 2);
              context.stroke();
            }
            if (isRoadDown) {
              context.beginPath();
              context.moveTo(cellX + plotStepTex / 2, cellY + plotStepTex / 2);
              context.lineTo(cellX + plotStepTex / 2, cellY + plotStepTex);
              context.stroke();
            }
            context.setLineDash([]); // Reset line dash
          }
        }
      }

      const texture = new THREE.CanvasTexture(canvas);
      // No repeat needed as texture covers the whole ground plane
      texture.needsUpdate = true;
      return texture;
    }


    // --- City Generation ---
    function generateCityLayout() {
      // Clear previous city elements
      clearCity();
      cityGrid = [];
      population = 0;

      const halfCitySize = citySize / 2;
      const plotStep = buildingPlotSize + pavementWidth * 2;
      const blockWidth = 4; // Number of plots wide for a block
      const blockHeight = 4; // Number of plots high for a block

      // Block-based Grid Layout
      for (let i = 0; i < gridSize; i++) {
        cityGrid[i] = [];
        for (let j = 0; j < gridSize; j++) {
          const x = -halfCitySize + plotStep / 2 + i * plotStep;
          const z = -halfCitySize + plotStep / 2 + j * plotStep;

          // Determine if the plot is on a block boundary (road)
          // Leave roads on the outer edges as well (i=0, j=0, etc.)
          const isRoad = (i % blockWidth === 0) || (j % blockHeight === 0);

          if (isRoad) {
            cityGrid[i][j] = { type: 'road', x, z };
          } else {
            // Inside a block - mostly buildings, occasional park
            const plotType = Math.random();
            if (plotType < 0.1) { // 10% chance of park inside block
              cityGrid[i][j] = { type: 'park', x, z };
            } else { // 90% chance of building inside block
              cityGrid[i][j] = { type: 'building', x, z };
            }
          }
        }
      }

      // --- Create Ground Texture based on Grid ---
      const groundTexture = createGroundTexture(); // Generate texture using the grid
      if (groundPlane && groundPlane.material) {
        groundPlane.material.map = groundTexture;
        groundPlane.material.needsUpdate = true;
      }
      // ---

      // Create elements based on grid
      createBuildingsInstanced();
      createInfrastructure();

      updateStatsDisplay();
    }

    function clearCity() {
      // Remove buildings (Iterate through the buildingMeshes object)
      for (const key in buildingMeshes) {
        const mesh = buildingMeshes[key];
        if (mesh) {
          scene.remove(mesh);
          // Dispose geometry ONLY if it's unique per mesh type (it's shared here)
          // mesh.geometry.dispose();
          mesh.material.dispose(); // Dispose material
        }
      }
      buildingMeshes = {}; // Reset the object

      // Remove window glows (No longer used with this approach)
      // if (windowGlowInstances) {
      //     scene.remove(windowGlowInstances);
      //     windowGlowInstances.geometry.dispose();
      //     windowGlowInstances.material.dispose();
      // }
      // windowGlowInstances = null;

      // Remove street lights
      streetLights.forEach(lightGroup => {
        scene.remove(lightGroup.light);
        scene.remove(lightGroup.pole);
        scene.remove(lightGroup.bulb); // Also remove the bulb mesh
        if (lightGroup.helper) scene.remove(lightGroup.helper);
      });
      streetLights = [];

      // Remove vehicles and dispose of their resources
      vehicles.forEach(vehicle => {
        // Traverse the group (vehicle.mesh) to dispose geometries and materials
        vehicle.mesh.traverse(child => {
          if (child.isMesh) {
            if (child.geometry) {
              child.geometry.dispose();
            }
            if (child.material) {
              // If materials are shared, be careful not to dispose them multiple times.
              // In this case, materials are cloned or unique per vehicle type/part, so disposing is okay.
              if (Array.isArray(child.material)) {
                child.material.forEach(material => material.dispose());
              } else {
                child.material.dispose();
              }
            }
          }
        });
        // Now remove the group itself from the scene
        scene.remove(vehicle.mesh);
      });
      vehicles = []; // Clear the array

      // Remove pedestrians
      pedestrians.forEach(ped => scene.remove(ped.mesh));
      pedestrians = [];

      // Remove parks/trees (Need to track these if added dynamically)
      // A simple way if trees are added directly to scene:
      // scene.children = scene.children.filter(child => !(child.isGroup && child.children.length === 2 && child.children[0].geometry instanceof THREE.CylinderGeometry)); // Basic check for tree groups
      // This is fragile; better to track park elements explicitly if complex.

      // TODO: Also remove park planes if added

      // Remove sidewalks
      if (sidewalkInstances) {
        scene.remove(sidewalkInstances);
        // Geometry is shared, dispose only if sure it's not used elsewhere (it is shared here)
        // sidewalkInstances.geometry.dispose();
        sidewalkInstances.material.dispose();
        sidewalkInstances = null;
      }
    }

    function regenerateCity() {
      generateCityLayout();
    }

    // --- Building Generation (Instanced per Material) ---
    function createBuildingsInstanced() {
      const buildingTypes = [
        // Define types with unique keys for materials/meshes
        { key: 'concrete', style: 'modern', color: 0xc0c0c0, texture: createBuildingTexture('concrete') },
        { key: 'brick', style: 'traditional', color: 0xcc8855, texture: createBuildingTexture('brick') }, // Keep original brick color tint
        { key: 'glass', style: 'office', color: 0xeeeeff, texture: createBuildingTexture('glass') }, // Keep original glass color tint
        { key: 'brick_tan', style: 'residential', color: 0xE0CFAF, texture: createBuildingTexture('brick_tan') }, // Tan brick
        { key: 'glass_dark', style: 'skyscraper', color: 0xAAAAEE, texture: createBuildingTexture('glass_dark') }, // Dark glass
        { key: 'stucco', style: 'commercial', color: 0xFFFFE0, texture: createBuildingTexture('stucco') }, // Light yellow stucco
      ];

      const baseGeometry = new THREE.BoxGeometry(1, 1, 1);
      baseGeometry.translate(0, 0.5, 0); // Move origin to base

      const maxInstancesPerType = gridSize * gridSize; // Max possible buildings for any type
      buildingMeshes = {}; // Reset meshes object
      const instanceCounts = {}; // Track count for each mesh type

      // Create materials and InstancedMesh for each building type
      buildingTypes.forEach(type => {
        const material = new THREE.MeshStandardMaterial({
          map: type.texture,
          color: type.color, // Use base color from type
          roughness: 0.8, // Adjust roughness/metalness as needed
          metalness: 0.1
          // NO vertexColors: true here
        });
        const mesh = new THREE.InstancedMesh(baseGeometry, material, maxInstancesPerType);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        buildingMeshes[type.key] = mesh; // Store mesh by key (e.g., 'brick')
        instanceCounts[type.key] = 0; // Initialize count
        scene.add(mesh); // Add mesh to the scene immediately
      });

      const dummy = new THREE.Object3D();
      population = 0;

      // Loop through grid to assign buildings to appropriate InstancedMesh
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (cityGrid[i][j].type === 'building') {
            const plot = cityGrid[i][j];
            const height = THREE.MathUtils.randInt(5, 30) * 5;
            const width = buildingPlotSize * THREE.MathUtils.randFloat(0.8, 1.0);
            const depth = buildingPlotSize * THREE.MathUtils.randFloat(0.8, 1.0);

            dummy.position.set(plot.x, 0, plot.z);
            dummy.scale.set(width, height, depth);
            dummy.updateMatrix();

            // Randomly select a building type/material
            const typeIndex = THREE.MathUtils.randInt(0, buildingTypes.length - 1);
            const selectedType = buildingTypes[typeIndex];
            const meshKey = selectedType.key; // e.g., 'brick'

            // Add instance to the corresponding InstancedMesh
            if (buildingMeshes[meshKey] && instanceCounts[meshKey] < maxInstancesPerType) {
              const currentCount = instanceCounts[meshKey];
              buildingMeshes[meshKey].setMatrixAt(currentCount, dummy.matrix);
              instanceCounts[meshKey]++; // Increment count for this type
            }

            // Add to population estimate
            population += Math.floor(height * width * depth / 500);
          }
        }
      }

      // Update counts and instance matrices for all meshes
      for (const key in buildingMeshes) {
        buildingMeshes[key].count = instanceCounts[key];
        buildingMeshes[key].instanceMatrix.needsUpdate = true;
      }

      // Window glow logic removed for simplicity with multiple meshes

      // baseGeometry.dispose(); // DO NOT dispose base geometry - it's shared by all InstancedMeshes
      // Materials will be disposed in clearCity
    }

    // Enhanced function to create building textures with more options
    function createBuildingTexture(type, options = {}) {
      const canvas = document.createElement('canvas');
      const size = 128;
      canvas.width = size;
      canvas.height = size;
      const context = canvas.getContext('2d');
      let baseColor = options.color || '#888'; // Use option color or default

      // --- Brick Variations ---
      if (type === 'brick' || type === 'brick_tan') {
        baseColor = options.color || (type === 'brick_tan' ? '#D2B48C' : '#b22222'); // Tan or Firebrick
        context.fillStyle = baseColor;
        context.fillRect(0, 0, size, size);
        context.strokeStyle = options.mortarColor || '#888'; // Mortar lines
        context.lineWidth = 2;
        // Horizontal lines
        for (let y = 0; y < size; y += 16) {
          context.beginPath();
          context.moveTo(0, y);
          context.lineTo(size, y);
          context.stroke();
        }
        // Vertical lines (staggered)
        for (let x = 0; x < size; x += 32) {
          for (let y = 0; y < size; y += 16) {
            context.beginPath();
            context.moveTo(x + (y % 32 === 0 ? 0 : 16), y);
            context.lineTo(x + (y % 32 === 0 ? 0 : 16), y + 16);
            context.stroke();
          }
        }
      }
      // --- Glass Variations ---
      else if (type === 'glass' || type === 'glass_dark') {
        baseColor = options.color || (type === 'glass_dark' ? '#556677' : '#add8e6'); // Dark or Light blue
        context.fillStyle = baseColor;
        context.fillRect(0, 0, size, size);
        context.strokeStyle = options.frameColor || '#444'; // Frames
        context.lineWidth = 4;
        const divisions = 4;
        for (let i = 0; i <= divisions; i++) {
          context.beginPath();
          // Vertical lines
          context.moveTo(i * size / divisions, 0);
          context.lineTo(i * size / divisions, size);
          // Horizontal lines
          context.moveTo(0, i * size / divisions);
          context.lineTo(size, i * size / divisions);
          context.stroke();
        }
        // Optional: Add subtle reflection/gradient
        if (type === 'glass_dark') {
          const gradient = context.createLinearGradient(0, 0, size, size);
          gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
          gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
          context.fillStyle = gradient;
          context.fillRect(0, 0, size, size);
        }
      }
      // --- Stucco Variation ---
      else if (type === 'stucco') {
        baseColor = options.color || '#F5F5DC'; // Beige default
        context.fillStyle = baseColor;
        context.fillRect(0, 0, size, size);
        // Add more pronounced noise for stucco effect
        context.fillStyle = 'rgba(0, 0, 0, 0.1)';
        for (let i = 0; i < 3000; i++) { // More dots
          context.fillRect(Math.random() * size, Math.random() * size, Math.random() * 2, Math.random() * 2); // Slightly larger dots
        }
      }
      // --- Concrete (Default) ---
      else { // 'concrete' or any other type falls here
        baseColor = options.color || '#888'; // Default concrete grey
        context.fillStyle = baseColor;
        context.fillRect(0, 0, size, size);
        context.fillStyle = 'rgba(0, 0, 0, 0.05)'; // Add some noise
        for (let i = 0; i < 1000; i++) {
          context.fillRect(Math.random() * size, Math.random() * size, 1, 1);
        }
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      // Adjust repeat based on type? Maybe glass repeats less?
      const repeatFactor = (type.includes('glass')) ? 2 : 4;
      texture.repeat.set(repeatFactor, repeatFactor * 2);
      return texture;
    }

    // --- Infrastructure ---
    function createInfrastructure() {
      const halfCitySize = citySize / 2;
      const plotStep = buildingPlotSize + pavementWidth * 2;
      const lightHeight = 15;
      const lightColor = 0xffffee;

      const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8, metalness: 0.5 });
      const poleGeometry = new THREE.CylinderGeometry(0.5, 0.5, lightHeight, 8);
      const lightMaterial = new THREE.MeshBasicMaterial({ color: lightColor }); // Emissive part
      const lightBulbGeometry = new THREE.SphereGeometry(1, 8, 8);

      // --- Sidewalk Setup ---
      const sidewalkHeight = 0.2;
      const sidewalkMaterial = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.9 });
      // Use a single BoxGeometry and scale/position instances
      const sidewalkGeometry = new THREE.BoxGeometry(1, 1, 1);
      sidewalkGeometry.translate(0, 0.5, 0); // Origin at bottom center
      const maxSidewalks = gridSize * gridSize * 4; // 4 segments per plot max
      sidewalkInstances = new THREE.InstancedMesh(sidewalkGeometry, sidewalkMaterial, maxSidewalks);
      sidewalkInstances.castShadow = false; // Sidewalks probably don't need to cast shadows
      sidewalkInstances.receiveShadow = true;
      scene.add(sidewalkInstances);
      let sidewalkCount = 0;
      const dummySidewalk = new THREE.Object3D();
      // --- End Sidewalk Setup ---


      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const plot = cityGrid[i][j];
          const isRoadIntersection = (i > 0 && cityGrid[i - 1][j].type !== 'building') &&
            (j > 0 && cityGrid[i][j - 1].type !== 'building') &&
            (i < gridSize - 1 && cityGrid[i + 1][j].type !== 'building') &&
            (j < gridSize - 1 && cityGrid[i][j + 1].type !== 'building');

          // Add Street Lights at corners/intersections (simplified placement)
          if (isRoadIntersection && Math.random() < 0.5) { // Place lights somewhat randomly at intersections
            const light = new THREE.PointLight(lightColor, 0, 50, 1); // Intensity 0 initially (off)
            light.position.set(plot.x + plotStep / 2, lightHeight, plot.z + plotStep / 2);
            light.castShadow = false; // Point lights shadows are expensive
            scene.add(light);

            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(light.position.x, lightHeight / 2, light.position.z);
            pole.castShadow = true;
            scene.add(pole);

            // Optional: Add a visual bulb
            const bulb = new THREE.Mesh(lightBulbGeometry, lightMaterial);
            bulb.position.copy(light.position);
            scene.add(bulb); // Add bulb to the pole group later if needed

            streetLights.push({ light: light, pole: pole, bulb: bulb, onIntensity: 1.5 });
          }

          // Add Parks (simple green squares with a few trees)
          if (plot.type === 'park') {
            // Use buildingPlotSize so the park mesh matches the green area on the texture
            const parkGeometry = new THREE.PlaneGeometry(buildingPlotSize, buildingPlotSize);
            const parkMaterial = new THREE.MeshStandardMaterial({ color: 0x55aa55 });
            const parkPlane = new THREE.Mesh(parkGeometry, parkMaterial);
            parkPlane.rotation.x = -Math.PI / 2;
            parkPlane.position.set(plot.x, 0.1, plot.z); // Slightly above ground
            parkPlane.receiveShadow = true;
            scene.add(parkPlane);

            // Add simple trees
            const treeCount = THREE.MathUtils.randInt(3, 8);
            for (let t = 0; t < treeCount; t++) {
              const tree = createSimpleTree();
              const treeX = plot.x + THREE.MathUtils.randFloat(-buildingPlotSize / 2.5, buildingPlotSize / 2.5);
              const treeZ = plot.z + THREE.MathUtils.randFloat(-buildingPlotSize / 2.5, buildingPlotSize / 2.5);
              tree.position.set(treeX, 0, treeZ);
              scene.add(tree);
            }
          }

          // --- Add Sidewalk Instances along Road Edges ---
          if (plot.type === 'building' || plot.type === 'park') {
            const halfPlotStep = plotStep / 2;
            const halfPavementWidth = pavementWidth / 2;

            // Check neighbor above (+Z)
            if (j < gridSize - 1 && cityGrid[i][j + 1].type === 'road') {
              dummySidewalk.position.set(plot.x, sidewalkHeight / 2, plot.z + halfPlotStep - halfPavementWidth);
              dummySidewalk.scale.set(plotStep, sidewalkHeight, pavementWidth);
              dummySidewalk.updateMatrix();
              if (sidewalkCount < maxSidewalks) sidewalkInstances.setMatrixAt(sidewalkCount++, dummySidewalk.matrix);
            }
            // Check neighbor below (-Z)
            if (j > 0 && cityGrid[i][j - 1].type === 'road') {
              dummySidewalk.position.set(plot.x, sidewalkHeight / 2, plot.z - halfPlotStep + halfPavementWidth);
              dummySidewalk.scale.set(plotStep, sidewalkHeight, pavementWidth);
              dummySidewalk.updateMatrix();
              if (sidewalkCount < maxSidewalks) sidewalkInstances.setMatrixAt(sidewalkCount++, dummySidewalk.matrix);
            }
            // Check neighbor right (+X)
            if (i < gridSize - 1 && cityGrid[i + 1][j].type === 'road') {
              dummySidewalk.position.set(plot.x + halfPlotStep - halfPavementWidth, sidewalkHeight / 2, plot.z);
              dummySidewalk.scale.set(pavementWidth, sidewalkHeight, plotStep);
              dummySidewalk.updateMatrix();
              if (sidewalkCount < maxSidewalks) sidewalkInstances.setMatrixAt(sidewalkCount++, dummySidewalk.matrix);
            }
            // Check neighbor left (-X)
            if (i > 0 && cityGrid[i - 1][j].type === 'road') {
              dummySidewalk.position.set(plot.x - halfPlotStep + halfPavementWidth, sidewalkHeight / 2, plot.z);
              dummySidewalk.scale.set(pavementWidth, sidewalkHeight, plotStep);
              dummySidewalk.updateMatrix();
              if (sidewalkCount < maxSidewalks) sidewalkInstances.setMatrixAt(sidewalkCount++, dummySidewalk.matrix);
            }
          }
          // --- End Sidewalk Instances ---

        } // End inner loop (j)
      } // End outer loop (i)

      // Update instance mesh count after loop
      if (sidewalkInstances) {
        sidewalkInstances.count = sidewalkCount;
        sidewalkInstances.instanceMatrix.needsUpdate = true;
      }

      poleGeometry.dispose();
      lightBulbGeometry.dispose();
      // Do NOT dispose sidewalkGeometry here as it's used by the InstancedMesh
    }

    function createSimpleTree() {
      const trunkHeight = THREE.MathUtils.randFloat(4, 8);
      const leavesHeight = THREE.MathUtils.randFloat(5, 10);
      const trunkGeo = new THREE.CylinderGeometry(0.5, 0.8, trunkHeight, 8);
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Brown
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = trunkHeight / 2;
      trunk.castShadow = true;

      const leavesGeo = new THREE.ConeGeometry(leavesHeight / 2, leavesHeight, 8);
      const leavesMat = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // ForestGreen
      const leaves = new THREE.Mesh(leavesGeo, leavesMat);
      leaves.position.y = trunkHeight + leavesHeight / 2;
      leaves.castShadow = true;

      const tree = new THREE.Group();
      tree.add(trunk);
      tree.add(leaves);
      return tree;
    }

    // --- Vehicle Geometry Creation --- (Removed createCarGeometry and createTruckGeometry)

    function createBusGeometry(material) {
      const group = new THREE.Group();
      const bodyHeight = 2.8;
      const bodyWidth = 3.0;
      const bodyLength = 10.0;

      // Body
      const bodyGeo = new THREE.BoxGeometry(bodyLength, bodyHeight, bodyWidth);
      const bodyMesh = new THREE.Mesh(bodyGeo, material);
      bodyMesh.position.y = bodyHeight / 2;
      bodyMesh.castShadow = true;
      group.add(bodyMesh);

      // Windows (simple darker band)
      const windowHeight = 1.0;
      const windowGeo = new THREE.BoxGeometry(bodyLength * 0.95, windowHeight, bodyWidth * 1.01); // Slightly wider
      const windowMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4, metalness: 0.1 });
      const windowMesh = new THREE.Mesh(windowGeo, windowMat);
      windowMesh.position.y = bodyHeight * 0.6; // Position windows higher up
      group.add(windowMesh);

      return group;
    }


    // --- Traffic System ---
    function createTraffic() {
      const vehicleTypes = [
        // Removed geometry, added random colors
        { type: 'car', material: new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, roughness: 0.6, metalness: 0.2 }), speedRange: [20, 40] },
        // { type: 'bus', material: new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.7, metalness: 0.1 }), speedRange: [15, 25] }, // Bus often white/grey
        { type: 'truck', material: new THREE.MeshStandardMaterial({ color: Math.random() * 0x888888 + 0x444444, roughness: 0.8, metalness: 0.1 }), speedRange: [18, 30] } // Truck darker colors
      ];
      const numVehicles = 50;
      const plotStep = buildingPlotSize + pavementWidth * 2;
      const halfRoadWidth = roadWidth / 2;

      for (let i = 0; i < numVehicles; i++) {
        const typeIndex = THREE.MathUtils.randInt(0, vehicleTypes.length - 1);
        const vehicleType = vehicleTypes[typeIndex];

        let vehicleMesh; // This will be a THREE.Group

        // Create geometry based on type
        switch (vehicleType.type) {
          case 'car':
            if (carModel) {
              vehicleMesh = carModel.clone(); // Clone the preloaded model
              // Apply random color to the cloned model's materials
              vehicleMesh.traverse(child => {
                if (child.isMesh) {
                  // Clone the material to avoid changing the original model's material
                  // Check if material is an array (multi-material object)
                  if (Array.isArray(child.material)) {
                    child.material = child.material.map(m => {
                      const clonedMaterial = m.clone();
                      clonedMaterial.color.set(Math.random() * 0xffffff);
                      clonedMaterial.roughness = 0.3; // Lower roughness for shinier look
                      clonedMaterial.metalness = 0.6; // Increase metalness
                      return clonedMaterial;
                    });
                  } else {
                    child.material = child.material.clone();
                    child.material.color.set(Math.random() * 0xffffff);
                    child.material.roughness = 0.3; // Lower roughness for shinier look
                    child.material.metalness = 0.6; // Increase metalness
                  }
                  child.castShadow = true; // Ensure shadows are cast
                }
              });
              // --- Adjust scale and position for car model ---
              // Set scale for car model
              const carScaleFactor = 10; // Adjusted scale (50% smaller than 20)
              vehicleMesh.scale.set(carScaleFactor, carScaleFactor, carScaleFactor);
              // Recalculate box after scaling
              const carBox = new THREE.Box3().setFromObject(vehicleMesh);
              // Adjust position so the bottom of the car is near y=0
              vehicleMesh.position.y = -carBox.min.y + 0.1; // Offset slightly above ground
              // Shadow properties are now set on the original loaded model, no need to traverse here
              // --- End Adjust ---
            } else { // Fallback if model didn't load
              const fallbackGeo = new THREE.BoxGeometry(4.5, 1.5, 2.5);
              vehicleMesh = new THREE.Mesh(fallbackGeo, vehicleType.material);
              vehicleMesh.position.y = 0.75 + 0.1; // Center + offset
              vehicleMesh.castShadow = true;
            }
            break;
          case 'bus':
            vehicleMesh = createBusGeometry(vehicleType.material); // Keep bus procedural for now
            // Ensure bus casts shadow
            vehicleMesh.traverse(child => { if (child.isMesh) child.castShadow = true; });
            vehicleMesh.position.y = 0.1; // Offset slightly above ground
            break;
          case 'truck':
            if (truckModel) {
              vehicleMesh = truckModel.clone(); // Clone the preloaded model
              // Apply random dark color to the cloned model's materials
              vehicleMesh.traverse(child => {
                if (child.isMesh) {
                  // Clone the material to avoid changing the original model's material
                  if (Array.isArray(child.material)) {
                    child.material = child.material.map(m => {
                      const clonedMaterial = m.clone();
                      clonedMaterial.color.set(Math.random() * 0xffffff); // Use full color range
                      clonedMaterial.roughness = 0.3; // Lower roughness for shinier look
                      clonedMaterial.metalness = 0.6; // Increase metalness
                      return clonedMaterial;
                    });
                  } else {
                    child.material = child.material.clone();
                    child.material.color.set(Math.random() * 0xffffff); // Use full color range
                    child.material.roughness = 0.3; // Lower roughness for shinier look
                    child.material.metalness = 0.6; // Increase metalness
                  }
                  child.castShadow = true; // Ensure shadows are cast
                }
              });
              // --- Adjust scale and position for truck model ---
              // Set a larger fixed scale to debug visibility
              const truckScaleFactor = 12; // Increase scale significantly
              vehicleMesh.scale.set(truckScaleFactor, truckScaleFactor, truckScaleFactor);
              // Recalculate box after scaling
              const truckBox = new THREE.Box3().setFromObject(vehicleMesh);
              // Adjust position so the bottom of the truck is near y=0
              vehicleMesh.position.y = -truckBox.min.y + 0.1; // Offset slightly above ground
              // Shadow properties are now set on the original loaded model, no need to traverse here
              // --- End Adjust ---
            } else { // Fallback if model didn't load
              const fallbackGeo = new THREE.BoxGeometry(9, 2.8, 3.0);
              vehicleMesh = new THREE.Mesh(fallbackGeo, vehicleType.material);
              vehicleMesh.position.y = 1.4 + 0.1; // Center + offset
              vehicleMesh.castShadow = true;
            }
            break;
          default: // Fallback to a simple box if type is unknown
            const fallbackGeo = new THREE.BoxGeometry(5, 2, 3);
            vehicleMesh = new THREE.Mesh(fallbackGeo, vehicleType.material);
            vehicleMesh.position.y = 1.1; // Box height/2 + offset
            vehicleMesh.castShadow = true; // Ensure fallback casts shadow too
            break;
        }

        // Set castShadow for all children of the group
        vehicleMesh.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            // child.receiveShadow = true; // Optional: vehicles could receive shadows
          }
        });

        // Position the group slightly above the ground - REMOVED line below, position is set in switch statement
        // vehicleMesh.position.y = 0.1;

        // Try to place on a 'road' grid line
        let placed = false;
        let attempts = 0;
        while (!placed && attempts < 100) { // Increased attempts to 100
          const gridX = THREE.MathUtils.randInt(0, gridSize - 1);
          const gridZ = THREE.MathUtils.randInt(0, gridSize - 1);
          const plot = cityGrid[gridX][gridZ];

          // Place near the center of a plot, offset for road lanes
          if (plot.type !== 'building') { // Place on non-building plots
            const direction = Math.random() > 0.5 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(0, 0, 1);
            if (Math.random() > 0.5) direction.multiplyScalar(-1); // Randomize initial direction along axis

            const laneOffset = halfRoadWidth / 2 * (Math.random() > 0.5 ? 1 : -1); // Offset slightly for lanes
            if (direction.x !== 0) { // Moving along X
              vehicleMesh.position.x = plot.x + THREE.MathUtils.randFloat(-plotStep / 3, plotStep / 3);
              vehicleMesh.position.z = plot.z + laneOffset;
              // Adjust rotation based on direction vector
              const angle = Math.atan2(direction.x, direction.z);
              vehicleMesh.rotation.y = angle;
            } else { // Moving along Z
              vehicleMesh.position.x = plot.x + laneOffset;
              vehicleMesh.position.z = plot.z + THREE.MathUtils.randFloat(-plotStep / 3, plotStep / 3);
              // Adjust rotation based on direction vector
              const angle = Math.atan2(direction.x, direction.z);
              vehicleMesh.rotation.y = angle;
            }

            vehicles.push({
              mesh: vehicleMesh, // The mesh is now the group
              speed: THREE.MathUtils.randFloat(vehicleType.speedRange[0], vehicleType.speedRange[1]),
              direction: direction
            });
            scene.add(vehicleMesh);
            placed = true;
          }
          attempts++;
        }
      }

      // No need to dispose shared geometries here anymore
      // vehicleTypes.forEach(vt => vt.geometry.dispose()); // REMOVED
    }

    function updateTraffic(deltaTime) {
      const halfCity = citySize / 2;
      const turnThreshold = buildingPlotSize / 2; // Distance before boundary to consider turning
      const plotStep = buildingPlotSize + pavementWidth * 2;
      // const halfCity = citySize / 2; // REMOVED - Already defined or accessible

      vehicles.forEach(vehicle => {
        // --- Obstacle Avoidance Check ---
        const potentialPosition = vehicle.mesh.position.clone().addScaledVector(vehicle.direction, vehicle.speed * deltaTime * 1.5); // Look ahead slightly further
        const gridX = Math.floor((potentialPosition.x + halfCity) / plotStep);
        const gridZ = Math.floor((potentialPosition.z + halfCity) / plotStep);

        let forcedTurn = false;
        if (gridX >= 0 && gridX < gridSize && gridZ >= 0 && gridZ < gridSize) {
          const nextPlotType = cityGrid[gridX][gridZ].type;
          if (nextPlotType === 'building' || nextPlotType === 'park') {
            // Obstacle ahead! Force a turn (randomly left or right)
            const turnAngle = (Math.random() > 0.5 ? 1 : -1) * Math.PI / 2;
            vehicle.direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), turnAngle);
            // Adjust mesh rotation
            const angle = Math.atan2(vehicle.direction.x, vehicle.direction.z);
            vehicle.mesh.rotation.y = angle;
            forcedTurn = true;
          }
        }
        // --- End Obstacle Avoidance ---

        // Move the vehicle regardless of whether a turn was forced by an obstacle
        // This might help it escape the obstacle zone instead of getting stuck turning in place.
        vehicle.mesh.position.addScaledVector(vehicle.direction, vehicle.speed * deltaTime);


        let turnedByBoundary = false; // Renamed 'turned' to avoid conflict
        // Boundary check and simple turning logic
        if (Math.abs(vehicle.mesh.position.x) > halfCity - turnThreshold || Math.abs(vehicle.mesh.position.z) > halfCity - turnThreshold) {
          // Near edge, 50% chance to turn onto the other axis if possible
          if (Math.random() < 0.5) {
            const currentAxis = Math.abs(vehicle.direction.x) > 0.1 ? 'x' : 'z';
            const newDir = new THREE.Vector3();
            if (currentAxis === 'x') {
              // Currently moving along X, want to turn to Z
              newDir.z = Math.sign(vehicle.mesh.position.z) || (Math.random() > 0.5 ? 1 : -1); // Turn towards center or random Z
            } else {
              // Currently moving along Z, want to turn to X
              newDir.x = Math.sign(vehicle.mesh.position.x) || (Math.random() > 0.5 ? 1 : -1); // Turn towards center or random X
            }
            // Ensure the new direction is normalized (though it should be axis-aligned here)
            newDir.normalize();
            vehicle.direction.copy(newDir);

            // CONSISTENTLY update rotation based on the *final* direction vector
            const angle = Math.atan2(vehicle.direction.x, vehicle.direction.z);
            vehicle.mesh.rotation.y = angle;

            turnedByBoundary = true; // Use the renamed variable
          }
        }

        // If didn't turn near edge (due to boundary), wrap around
        if (!forcedTurn && !turnedByBoundary) { // Also check forcedTurn
          if (Math.abs(vehicle.mesh.position.x) > halfCity) {
            vehicle.mesh.position.x = Math.sign(vehicle.mesh.position.x) * -halfCity * 0.98;
          }
          if (Math.abs(vehicle.mesh.position.z) > halfCity) {
            vehicle.mesh.position.z = Math.sign(vehicle.mesh.position.z) * -halfCity * 0.98;
          }
        }

        // TODO: Add intersection logic, collision avoidance
      });
    }

    // Pedestrian functions are now imported from pedestrian_functions.js


    // --- Day/Night Cycle ---
    function updateDayNightCycle(deltaTime) {
      // timeOfDay = (timeOfDay + deltaTime * cycleSpeed) % 1; // REMOVED: Automatic cycling disabled

      // Calculate sun position (simple approximation)
      const sunAngle = timeOfDay * Math.PI * 2 - Math.PI / 2; // -PI/2 to PI*1.5
      directionalLight.position.x = 150 * Math.cos(sunAngle);
      directionalLight.position.y = 300 * Math.sin(sunAngle + Math.PI / 2); // Peak at noon
      directionalLight.target.position.set(0, 0, 0); // Keep target at origin

      // Adjust light intensity and color based on time
      const dayIntensity = Math.max(0, Math.sin(timeOfDay * Math.PI)); // Strongest at noon (0.5)
      // Increase night base intensity slightly and its multiplier
      const nightIntensity = 0.15 + Math.max(0, Math.sin((timeOfDay + 0.5) % 1 * Math.PI)) * 0.3;

      // Increase base multipliers for brighter overall lighting (Increased multipliers)
      directionalLight.intensity = dayIntensity * 2.0; // Brighter sun
      ambientLight.intensity = dayIntensity * 0.9 + nightIntensity * 0.4; // Brighter ambient day & night
      hemisphereLight.intensity = dayIntensity * 0.7 + nightIntensity * 0.3; // Brighter hemisphere day & night

      // Sky color interpolation
      const daySkyColor = new THREE.Color(0x87ceeb);
      const nightSkyColor = new THREE.Color(0x000020);
      const horizonColor = new THREE.Color(0xffaa66); // Sunset/sunrise color
      const sunsetFactor = Math.pow(Math.abs(Math.sin(timeOfDay * Math.PI)), 4); // Stronger effect near sunrise/sunset

      let currentSkyColor = daySkyColor.clone().lerp(nightSkyColor, 1 - dayIntensity);
      currentSkyColor.lerp(horizonColor, sunsetFactor * 0.5); // Add sunset color influence

      scene.background = currentSkyColor;
      hemisphereLight.color.copy(currentSkyColor); // Match hemisphere sky color
      hemisphereLight.groundColor.set(0x080820).lerp(new THREE.Color(0x404040), dayIntensity); // Darker ground at night

      // Update fog
      if (scene.fog) {
        scene.fog.color.copy(scene.background);
      } else {
        scene.fog = new THREE.Fog(scene.background, camera.near + 200, camera.far - 500);
      }
      scene.fog.color.copy(scene.background); // Keep fog color matching sky


      // Update street lights
      isDay = dayIntensity > 0.1; // Threshold for day

      // Toggle window glow visibility (REMOVED as window glows were removed)
      // if (windowGlowInstances) {
      //     windowGlowInstances.visible = !isDay;
      // }

      const targetStreetlightIntensity = isDay ? 0 : 1.0;
      streetLights.forEach(lightGroup => {
        // Smooth transition for light intensity
        lightGroup.light.intensity += (targetStreetlightIntensity * lightGroup.onIntensity - lightGroup.light.intensity) * 0.1;
        // Toggle bulb visibility/material based on intensity (optional)
        lightGroup.bulb.material.opacity = lightGroup.light.intensity / lightGroup.onIntensity; // Fade bulb
      });

      // Update building window emission (placeholder - needs shader or material swap)
      // This is tricky with InstancedMesh without custom shaders.
      // A simple approach: could swap materials, but that breaks instancing benefits.
      // Alternative: Use vertex colors or a texture lookup in a shader.
      // For now, we won't implement emissive windows on the instanced mesh easily.

      updateStatsDisplay(); // Update time display
    }

    function toggleDayNightManual() {
      // Check current state (isDay is updated in updateDayNightCycle)
      if (isDay) {
        // Currently Day -> Switch to Night
        timeOfDay = 0.0; // Midnight
      } else {
        // Currently Night -> Switch to Day
        timeOfDay = 0.5; // Noon
      }
      // Force immediate update of lighting, etc. based on new timeOfDay
      updateDayNightCycle(0); // Pass 0 deltaTime as it's an instant change
    }

    // --- User Interface ---
    function updateStatsDisplay() {
      let timeString = "Night";
      if (timeOfDay > 0.25 && timeOfDay < 0.75) timeString = "Day";
      if (timeOfDay > 0.2 && timeOfDay < 0.3) timeString = "Sunrise";
      if (timeOfDay > 0.7 && timeOfDay < 0.8) timeString = "Sunset";

      document.getElementById('timeOfDay').textContent = timeString + ` (${timeOfDay.toFixed(2)})`;
      document.getElementById('population').textContent = population.toLocaleString();
    }

    // --- Window Resize ---
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);

      const deltaTime = clock.getDelta();

      // Update systems
      controls.update();
      updateDayNightCycle(deltaTime);
      updateTraffic(deltaTime); // Update improved traffic
      updatePedestrians(deltaTime, THREE, pedestrians, cityGrid, gridSize, citySize, buildingPlotSize, pavementWidth); // Update pedestrians

      // Render
      renderer.render(scene, camera);

      // Update Stats
      stats.update();
    }

    // --- Start ---
    loadModelsAndInit(); // Load models first, then initialize

  </script>
</body>

</html>